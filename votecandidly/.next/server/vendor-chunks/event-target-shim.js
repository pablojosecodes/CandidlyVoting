"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/event-target-shim";
exports.ids = ["vendor-chunks/event-target-shim"];
exports.modules = {

/***/ "(rsc)/./node_modules/event-target-shim/dist/event-target-shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/event-target-shim/dist/event-target-shim.js ***!
  \******************************************************************/
/***/ ((module, exports) => {

eval("/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */ /**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */ const privateData = new WeakMap();\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */ const wrappers = new WeakMap();\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */ function pd(event) {\n    const retv = privateData.get(event);\n    console.assert(retv != null, \"'this' is expected an Event object, but got\", event);\n    return retv;\n}\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */ function setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n            console.error(\"Unable to preventDefault inside passive event listener invocation.\", data.passiveListener);\n        }\n        return;\n    }\n    if (!data.event.cancelable) {\n        return;\n    }\n    data.canceled = true;\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault();\n    }\n}\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */ /**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */ function Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now()\n    });\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", {\n        value: false,\n        enumerable: true\n    });\n    // Define accessors\n    const keys = Object.keys(event);\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key));\n        }\n    }\n}\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */ get type () {\n        return pd(this).event.type;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */ get target () {\n        return pd(this).eventTarget;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */ get currentTarget () {\n        return pd(this).currentTarget;\n    },\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */ composedPath () {\n        const currentTarget = pd(this).currentTarget;\n        if (currentTarget == null) {\n            return [];\n        }\n        return [\n            currentTarget\n        ];\n    },\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */ get NONE () {\n        return 0;\n    },\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */ get CAPTURING_PHASE () {\n        return 1;\n    },\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */ get AT_TARGET () {\n        return 2;\n    },\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */ get BUBBLING_PHASE () {\n        return 3;\n    },\n    /**\n     * The target of this event.\n     * @type {number}\n     */ get eventPhase () {\n        return pd(this).eventPhase;\n    },\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */ stopPropagation () {\n        const data = pd(this);\n        data.stopped = true;\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation();\n        }\n    },\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */ stopImmediatePropagation () {\n        const data = pd(this);\n        data.stopped = true;\n        data.immediateStopped = true;\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation();\n        }\n    },\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */ get bubbles () {\n        return Boolean(pd(this).event.bubbles);\n    },\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */ get cancelable () {\n        return Boolean(pd(this).event.cancelable);\n    },\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */ preventDefault () {\n        setCancelFlag(pd(this));\n    },\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */ get defaultPrevented () {\n        return pd(this).canceled;\n    },\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */ get composed () {\n        return Boolean(pd(this).event.composed);\n    },\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */ get timeStamp () {\n        return pd(this).timeStamp;\n    },\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */ get srcElement () {\n        return pd(this).eventTarget;\n    },\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */ get cancelBubble () {\n        return pd(this).stopped;\n    },\n    set cancelBubble (value){\n        if (!value) {\n            return;\n        }\n        const data = pd(this);\n        data.stopped = true;\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true;\n        }\n    },\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */ get returnValue () {\n        return !pd(this).canceled;\n    },\n    set returnValue (value){\n        if (!value) {\n            setCancelFlag(pd(this));\n        }\n    },\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */ initEvent () {\n    // Do nothing.\n    }\n};\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true\n});\n// Ensure `event instanceof window.Event` is `true`.\nif (false) {}\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */ function defineRedirectDescriptor(key) {\n    return {\n        get () {\n            return pd(this).event[key];\n        },\n        set (value1) {\n            pd(this).event[key] = value1;\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */ function defineCallDescriptor(key) {\n    return {\n        value () {\n            const event = pd(this).event;\n            return event[key].apply(event, arguments);\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */ function defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto);\n    if (keys.length === 0) {\n        return BaseEvent;\n    }\n    /** CustomEvent */ function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event);\n    }\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: {\n            value: CustomEvent,\n            configurable: true,\n            writable: true\n        }\n    });\n    // Define accessors.\n    for(let i = 0; i < keys.length; ++i){\n        const key = keys[i];\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n            const isFunc = typeof descriptor.value === \"function\";\n            Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));\n        }\n    }\n    return CustomEvent;\n}\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */ function getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event;\n    }\n    let wrapper = wrappers.get(proto);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n        wrappers.set(proto, wrapper);\n    }\n    return wrapper;\n}\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */ function wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event));\n    return new Wrapper(eventTarget, event);\n}\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */ function isStopped(event) {\n    return pd(event).immediateStopped;\n}\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */ function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase;\n}\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */ function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget;\n}\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */ function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener;\n}\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */ /**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */ const listenersMap = new WeakMap();\n// Listener types\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */ function isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n    ;\n}\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */ function getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget);\n    if (listeners == null) {\n        throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\");\n    }\n    return listeners;\n}\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */ function defineEventAttributeDescriptor(eventName) {\n    return {\n        get () {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while(node != null){\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener;\n                }\n                node = node.next;\n            }\n            return null;\n        },\n        set (listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while(node != null){\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    } else {\n                        listeners.delete(eventName);\n                    }\n                } else {\n                    prev = node;\n                }\n                node = node.next;\n            }\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                } else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true\n    };\n}\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */ function defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));\n}\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */ function defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */ function CustomEventTarget() {\n        EventTarget.call(this);\n    }\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true\n        }\n    });\n    for(let i = 0; i < eventNames.length; ++i){\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n    }\n    return CustomEventTarget;\n}\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */ function EventTarget() {\n    /*eslint-disable consistent-return */ if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map());\n        return;\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0]);\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length);\n        for(let i = 0; i < arguments.length; ++i){\n            types[i] = arguments[i];\n        }\n        return defineCustomEventTarget(types);\n    }\n    throw new TypeError(\"Cannot call a class as a function\");\n/*eslint-enable consistent-return */ }\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */ addEventListener (eventName, listener, options) {\n        if (listener == null) {\n            return;\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\");\n        }\n        const listeners = getListeners(this);\n        const optionsIsObj = isObject(options);\n        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null\n        };\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName);\n        if (node === undefined) {\n            listeners.set(eventName, newNode);\n            return;\n        }\n        // Traverse to the tail while checking duplication..\n        let prev = null;\n        while(node != null){\n            if (node.listener === listener && node.listenerType === listenerType) {\n                // Should ignore duplication.\n                return;\n            }\n            prev = node;\n            node = node.next;\n        }\n        // Add it.\n        prev.next = newNode;\n    },\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */ removeEventListener (eventName, listener, options) {\n        if (listener == null) {\n            return;\n        }\n        const listeners = getListeners(this);\n        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        let prev = null;\n        let node = listeners.get(eventName);\n        while(node != null){\n            if (node.listener === listener && node.listenerType === listenerType) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n                return;\n            }\n            prev = node;\n            node = node.next;\n        }\n    },\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */ dispatchEvent (event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.');\n        }\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this);\n        const eventName = event.type;\n        let node = listeners.get(eventName);\n        if (node == null) {\n            return true;\n        }\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event);\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null;\n        while(node != null){\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n            } else {\n                prev = node;\n            }\n            // Call this listener\n            setPassiveListener(wrappedEvent, node.passive ? node.listener : null);\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent);\n                } catch (err) {\n                    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n                        console.error(err);\n                    }\n                }\n            } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === \"function\") {\n                node.listener.handleEvent(wrappedEvent);\n            }\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break;\n            }\n            node = node.next;\n        }\n        setPassiveListener(wrappedEvent, null);\n        setEventPhase(wrappedEvent, 0);\n        setCurrentTarget(wrappedEvent, null);\n        return !wrappedEvent.defaultPrevented;\n    }\n};\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true\n});\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (false) {}\nexports.defineEventAttribute = defineEventAttribute;\nexports.EventTarget = EventTarget;\nexports[\"default\"] = EventTarget;\nmodule.exports = EventTarget;\nmodule.exports.EventTarget = module.exports[\"default\"] = EventTarget;\nmodule.exports.defineEventAttribute = defineEventAttribute //# sourceMappingURL=event-target-shim.js.map\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXZlbnQtdGFyZ2V0LXNoaW0vZGlzdC9ldmVudC10YXJnZXQtc2hpbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDLEdBQ0Q7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFFN0Q7Ozs7Ozs7Ozs7OztDQVlDLEdBRUQ7Ozs7Q0FJQyxHQUNELE1BQU1DLGNBQWMsSUFBSUM7QUFFeEI7Ozs7Q0FJQyxHQUNELE1BQU1DLFdBQVcsSUFBSUQ7QUFFckI7Ozs7O0NBS0MsR0FDRCxTQUFTRSxHQUFHQyxLQUFLO0lBQ2IsTUFBTUMsT0FBT0wsWUFBWU0sR0FBRyxDQUFDRjtJQUM3QkcsUUFBUUMsTUFBTSxDQUNWSCxRQUFRLE1BQ1IsK0NBQ0FEO0lBRUosT0FBT0M7QUFDWDtBQUVBOzs7Q0FHQyxHQUNELFNBQVNJLGNBQWNDLElBQUk7SUFDdkIsSUFBSUEsS0FBS0MsZUFBZSxJQUFJLE1BQU07UUFDOUIsSUFDSSxPQUFPSixZQUFZLGVBQ25CLE9BQU9BLFFBQVFLLEtBQUssS0FBSyxZQUMzQjtZQUNFTCxRQUFRSyxLQUFLLENBQ1Qsc0VBQ0FGLEtBQUtDLGVBQWU7UUFFNUI7UUFDQTtJQUNKO0lBQ0EsSUFBSSxDQUFDRCxLQUFLTixLQUFLLENBQUNTLFVBQVUsRUFBRTtRQUN4QjtJQUNKO0lBRUFILEtBQUtJLFFBQVEsR0FBRztJQUNoQixJQUFJLE9BQU9KLEtBQUtOLEtBQUssQ0FBQ1csY0FBYyxLQUFLLFlBQVk7UUFDakRMLEtBQUtOLEtBQUssQ0FBQ1csY0FBYztJQUM3QjtBQUNKO0FBRUE7OztDQUdDLEdBQ0Q7Ozs7O0NBS0MsR0FDRCxTQUFTQyxNQUFNQyxXQUFXLEVBQUViLEtBQUs7SUFDN0JKLFlBQVlrQixHQUFHLENBQUMsSUFBSSxFQUFFO1FBQ2xCRDtRQUNBYjtRQUNBZSxZQUFZO1FBQ1pDLGVBQWVIO1FBQ2ZILFVBQVU7UUFDVk8sU0FBUztRQUNUQyxrQkFBa0I7UUFDbEJYLGlCQUFpQjtR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S0FBS0MsWUFBWSxLQUFLVCxhQUN0QixPQUFPUSxLQUFLRSxRQUFRLENBQUMwQixXQUFXLEtBQUssWUFDdkM7Z0JBQ0U1QixLQUFLRSxRQUFRLENBQUMwQixXQUFXLENBQUNGO1lBQzlCO1lBRUEsd0RBQXdEO1lBQ3hELElBQUl6QyxVQUFVeUMsZUFBZTtnQkFDekI7WUFDSjtZQUVBMUIsT0FBT0EsS0FBS0csSUFBSTtRQUNwQjtRQUNBZixtQkFBbUJzQyxjQUFjO1FBQ2pDeEMsY0FBY3dDLGNBQWM7UUFDNUJ2QyxpQkFBaUJ1QyxjQUFjO1FBRS9CLE9BQU8sQ0FBQ0EsYUFBYXJFLGdCQUFnQjtJQUN6QztBQUNKO0FBRUEsbUNBQW1DO0FBQ25DaEQsT0FBT0MsY0FBYyxDQUFDd0csWUFBWXJFLFNBQVMsRUFBRSxlQUFlO0lBQ3hEakMsT0FBT3NHO0lBQ1BuRCxjQUFjO0lBQ2RDLFVBQVU7QUFDZDtBQUVBLGdFQUFnRTtBQUNoRSxJQUNJLEtBQ3lDLEVBQzNDLEVBRUQ7QUFFRHJELDRCQUE0QixHQUFHa0c7QUFDL0JsRyxtQkFBbUIsR0FBR3VHO0FBQ3RCdkcsa0JBQWUsR0FBR3VHO0FBRWxCZ0IsT0FBT3ZILE9BQU8sR0FBR3VHO0FBQ2pCZ0IsMEJBQTBCLEdBQUdBLHlCQUF5QixHQUFHaEI7QUFDekRnQixtQ0FBbUMsR0FBR3JCLHFCQUN0Qyw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYW1lLy4vbm9kZV9tb2R1bGVzL2V2ZW50LXRhcmdldC1zaGltL2Rpc3QvZXZlbnQtdGFyZ2V0LXNoaW0uanM/ZTI1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBhdXRob3IgVG9ydSBOYWdhc2hpbWEgPGh0dHBzOi8vZ2l0aHViLmNvbS9teXN0aWNhdGVhPlxuICogQGNvcHlyaWdodCAyMDE1IFRvcnUgTmFnYXNoaW1hLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU2VlIExJQ0VOU0UgZmlsZSBpbiByb290IGRpcmVjdG9yeSBmb3IgZnVsbCBsaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gUHJpdmF0ZURhdGFcbiAqIEBwcm9wZXJ0eSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQuXG4gKiBAcHJvcGVydHkge3t0eXBlOnN0cmluZ319IGV2ZW50IFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZXZlbnRQaGFzZSBUaGUgY3VycmVudCBldmVudCBwaGFzZS5cbiAqIEBwcm9wZXJ0eSB7RXZlbnRUYXJnZXR8bnVsbH0gY3VycmVudFRhcmdldCBUaGUgY3VycmVudCBldmVudCB0YXJnZXQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNhbmNlbGVkIFRoZSBmbGFnIHRvIHByZXZlbnQgZGVmYXVsdC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3RvcHBlZCBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBpbW1lZGlhdGVTdG9wcGVkIFRoZSBmbGFnIHRvIHN0b3AgcHJvcGFnYXRpb24gaW1tZWRpYXRlbHkuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufG51bGx9IHBhc3NpdmVMaXN0ZW5lciBUaGUgbGlzdGVuZXIgaWYgdGhlIGN1cnJlbnQgbGlzdGVuZXIgaXMgcGFzc2l2ZS4gT3RoZXJ3aXNlIHRoaXMgaXMgbnVsbC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lU3RhbXAgVGhlIHVuaXggdGltZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBQcml2YXRlIGRhdGEgZm9yIGV2ZW50IHdyYXBwZXJzLlxuICogQHR5cGUge1dlYWtNYXA8RXZlbnQsIFByaXZhdGVEYXRhPn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHByaXZhdGVEYXRhID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBDYWNoZSBmb3Igd3JhcHBlciBjbGFzc2VzLlxuICogQHR5cGUge1dlYWtNYXA8T2JqZWN0LCBGdW5jdGlvbj59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB3cmFwcGVycyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogR2V0IHByaXZhdGUgZGF0YS5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCBvYmplY3QgdG8gZ2V0IHByaXZhdGUgZGF0YS5cbiAqIEByZXR1cm5zIHtQcml2YXRlRGF0YX0gVGhlIHByaXZhdGUgZGF0YSBvZiB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwZChldmVudCkge1xuICAgIGNvbnN0IHJldHYgPSBwcml2YXRlRGF0YS5nZXQoZXZlbnQpO1xuICAgIGNvbnNvbGUuYXNzZXJ0KFxuICAgICAgICByZXR2ICE9IG51bGwsXG4gICAgICAgIFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50IG9iamVjdCwgYnV0IGdvdFwiLFxuICAgICAgICBldmVudFxuICAgICk7XG4gICAgcmV0dXJuIHJldHZcbn1cblxuLyoqXG4gKiBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI3NldC10aGUtY2FuY2VsZWQtZmxhZ1xuICogQHBhcmFtIGRhdGEge1ByaXZhdGVEYXRhfSBwcml2YXRlIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHNldENhbmNlbEZsYWcoZGF0YSkge1xuICAgIGlmIChkYXRhLnBhc3NpdmVMaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlVuYWJsZSB0byBwcmV2ZW50RGVmYXVsdCBpbnNpZGUgcGFzc2l2ZSBldmVudCBsaXN0ZW5lciBpbnZvY2F0aW9uLlwiLFxuICAgICAgICAgICAgICAgIGRhdGEucGFzc2l2ZUxpc3RlbmVyXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIWRhdGEuZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBkYXRhLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQucHJldmVudERlZmF1bHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBkYXRhLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbi8qKlxuICogVGhlIGV2ZW50IHdyYXBwZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgb2YgdGhpcyBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7RXZlbnR8e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50IHRvIHdyYXAuXG4gKi9cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgIHByaXZhdGVEYXRhLnNldCh0aGlzLCB7XG4gICAgICAgIGV2ZW50VGFyZ2V0LFxuICAgICAgICBldmVudCxcbiAgICAgICAgZXZlbnRQaGFzZTogMixcbiAgICAgICAgY3VycmVudFRhcmdldDogZXZlbnRUYXJnZXQsXG4gICAgICAgIGNhbmNlbGVkOiBmYWxzZSxcbiAgICAgICAgc3RvcHBlZDogZmFsc2UsXG4gICAgICAgIGltbWVkaWF0ZVN0b3BwZWQ6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlTGlzdGVuZXI6IG51bGwsXG4gICAgICAgIHRpbWVTdGFtcDogZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCksXG4gICAgfSk7XG5cbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNVbmZvcmdlYWJsZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzVHJ1c3RlZFwiLCB7IHZhbHVlOiBmYWxzZSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuICAgIC8vIERlZmluZSBhY2Nlc3NvcnNcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIShrZXkgaW4gdGhpcykpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gU2hvdWxkIGJlIGVudW1lcmFibGUsIGJ1dCBjbGFzcyBtZXRob2RzIGFyZSBub3QgZW51bWVyYWJsZS5cbkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudC50eXBlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XG4gICAgICovXG4gICAgZ2V0IHRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50VGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5jdXJyZW50VGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtFdmVudFRhcmdldFtdfSBUaGUgY29tcG9zZWQgcGF0aCBvZiB0aGlzIGV2ZW50LlxuICAgICAqL1xuICAgIGNvbXBvc2VkUGF0aCgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRhcmdldCA9IHBkKHRoaXMpLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIGlmIChjdXJyZW50VGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY3VycmVudFRhcmdldF1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RhbnQgb2YgTk9ORS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBOT05FKCkge1xuICAgICAgICByZXR1cm4gMFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBDQVBUVVJJTkdfUEhBU0UuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgQ0FQVFVSSU5HX1BIQVNFKCkge1xuICAgICAgICByZXR1cm4gMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBBVF9UQVJHRVQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgQVRfVEFSR0VUKCkge1xuICAgICAgICByZXR1cm4gMlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBCVUJCTElOR19QSEFTRS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBCVUJCTElOR19QSEFTRSgpIHtcbiAgICAgICAgcmV0dXJuIDNcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGV2ZW50UGhhc2UoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFBoYXNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcyk7XG5cbiAgICAgICAgZGF0YS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcyk7XG5cbiAgICAgICAgZGF0YS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YS5pbW1lZGlhdGVTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGJ1YmJsaW5nLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBidWJibGVzKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwZCh0aGlzKS5ldmVudC5idWJibGVzKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBiZSBjYW5jZWxhYmxlLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjYW5jZWxhYmxlKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwZCh0aGlzKS5ldmVudC5jYW5jZWxhYmxlKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgdGhpcyBldmVudC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgc2V0Q2FuY2VsRmxhZyhwZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGluZGljYXRlIGNhbmNlbGxhdGlvbiBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgZGVmYXVsdFByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmNhbmNlbGVkXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGNvbXBvc2VkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjb21wb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGQodGhpcykuZXZlbnQuY29tcG9zZWQpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB1bml4IHRpbWUgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB0aW1lU3RhbXAoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS50aW1lU3RhbXBcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCBzcmNFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRUYXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gc3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCBjYW5jZWxCdWJibGUoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5zdG9wcGVkXG4gICAgfSxcbiAgICBzZXQgY2FuY2VsQnViYmxlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKTtcblxuICAgICAgICBkYXRhLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQuY2FuY2VsQnViYmxlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgZGF0YS5ldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGluZGljYXRlIGNhbmNlbGxhdGlvbiBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCByZXR1cm5WYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuICFwZCh0aGlzKS5jYW5jZWxlZFxuICAgIH0sXG4gICAgc2V0IHJldHVyblZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHNldENhbmNlbEZsYWcocGQodGhpcykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhpcyBldmVudCBvYmplY3QuIEJ1dCBkbyBub3RoaW5nIHVuZGVyIGV2ZW50IGRpc3BhdGNoaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIFRoZSBmbGFnIHRvIGJlIHBvc3NpYmxlIHRvIGJ1YmJsZSB1cC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjYW5jZWxhYmxlPWZhbHNlXSBUaGUgZmxhZyB0byBiZSBwb3NzaWJsZSB0byBjYW5jZWwuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBpbml0RXZlbnQoKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgfSxcbn07XG5cbi8vIGBjb25zdHJ1Y3RvcmAgaXMgbm90IGVudW1lcmFibGUuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHtcbiAgICB2YWx1ZTogRXZlbnQsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxufSk7XG5cbi8vIEVuc3VyZSBgZXZlbnQgaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnRgIGlzIGB0cnVlYC5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRXZlbnQucHJvdG90eXBlLCB3aW5kb3cuRXZlbnQucHJvdG90eXBlKTtcblxuICAgIC8vIE1ha2UgYXNzb2NpYXRpb24gZm9yIHdyYXBwZXJzLlxuICAgIHdyYXBwZXJzLnNldCh3aW5kb3cuRXZlbnQucHJvdG90eXBlLCBFdmVudCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIHJlZGlyZWN0IGEgZ2l2ZW4gcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFByb3BlcnR5IG5hbWUgdG8gZGVmaW5lIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7UHJvcGVydHlEZXNjcmlwdG9yfSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byByZWRpcmVjdCB0aGUgcHJvcGVydHkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3Ioa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50W2tleV1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICBwZCh0aGlzKS5ldmVudFtrZXldID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIGNhbGwgYSBnaXZlbiBtZXRob2QgcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFByb3BlcnR5IG5hbWUgdG8gZGVmaW5lIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7UHJvcGVydHlEZXNjcmlwdG9yfSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byBjYWxsIHRoZSBtZXRob2QgcHJvcGVydHkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVDYWxsRGVzY3JpcHRvcihrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gcGQodGhpcykuZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRba2V5XS5hcHBseShldmVudCwgYXJndW1lbnRzKVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIERlZmluZSBuZXcgd3JhcHBlciBjbGFzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IEJhc2VFdmVudCBUaGUgYmFzZSB3cmFwcGVyIGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBwcm90b3R5cGUgb2YgdGhlIG9yaWdpbmFsIGV2ZW50LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgZGVmaW5lZCB3cmFwcGVyIGNsYXNzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lV3JhcHBlcihCYXNlRXZlbnQsIHByb3RvKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3RvKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJhc2VFdmVudFxuICAgIH1cblxuICAgIC8qKiBDdXN0b21FdmVudCAqL1xuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgICAgICBCYXNlRXZlbnQuY2FsbCh0aGlzLCBldmVudFRhcmdldCwgZXZlbnQpO1xuICAgIH1cblxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUV2ZW50LnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogQ3VzdG9tRXZlbnQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICB9KTtcblxuICAgIC8vIERlZmluZSBhY2Nlc3NvcnMuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghKGtleSBpbiBCYXNlRXZlbnQucHJvdG90eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGtleSk7XG4gICAgICAgICAgICBjb25zdCBpc0Z1bmMgPSB0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgaXNGdW5jXG4gICAgICAgICAgICAgICAgICAgID8gZGVmaW5lQ2FsbERlc2NyaXB0b3Ioa2V5KVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50XG59XG5cbi8qKlxuICogR2V0IHRoZSB3cmFwcGVyIGNsYXNzIG9mIGEgZ2l2ZW4gcHJvdG90eXBlLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBwcm90b3R5cGUgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIGdldCBpdHMgd3JhcHBlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIHdyYXBwZXIgY2xhc3MuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRXcmFwcGVyKHByb3RvKSB7XG4gICAgaWYgKHByb3RvID09IG51bGwgfHwgcHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgcmV0dXJuIEV2ZW50XG4gICAgfVxuXG4gICAgbGV0IHdyYXBwZXIgPSB3cmFwcGVycy5nZXQocHJvdG8pO1xuICAgIGlmICh3cmFwcGVyID09IG51bGwpIHtcbiAgICAgICAgd3JhcHBlciA9IGRlZmluZVdyYXBwZXIoZ2V0V3JhcHBlcihPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pKSwgcHJvdG8pO1xuICAgICAgICB3cmFwcGVycy5zZXQocHJvdG8sIHdyYXBwZXIpO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcHBlclxufVxuXG4vKipcbiAqIFdyYXAgYSBnaXZlbiBldmVudCB0byBtYW5hZ2VtZW50IGEgZGlzcGF0Y2hpbmcuXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0IG9mIHRoaXMgZGlzcGF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHRvIHdyYXAuXG4gKiBAcmV0dXJucyB7RXZlbnR9IFRoZSB3cmFwcGVyIGluc3RhbmNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gd3JhcEV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgIGNvbnN0IFdyYXBwZXIgPSBnZXRXcmFwcGVyKE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCkpO1xuICAgIHJldHVybiBuZXcgV3JhcHBlcihldmVudFRhcmdldCwgZXZlbnQpXG59XG5cbi8qKlxuICogR2V0IHRoZSBpbW1lZGlhdGVTdG9wcGVkIGZsYWcgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGZsYWcgdG8gc3RvcCBwcm9wYWdhdGlvbiBpbW1lZGlhdGVseS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzU3RvcHBlZChldmVudCkge1xuICAgIHJldHVybiBwZChldmVudCkuaW1tZWRpYXRlU3RvcHBlZFxufVxuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCBldmVudCBwaGFzZSBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIHNldCBjdXJyZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBldmVudFBoYXNlIE5ldyBldmVudCBwaGFzZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0RXZlbnRQaGFzZShldmVudCwgZXZlbnRQaGFzZSkge1xuICAgIHBkKGV2ZW50KS5ldmVudFBoYXNlID0gZXZlbnRQaGFzZTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgdGFyZ2V0IG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtFdmVudFRhcmdldHxudWxsfSBjdXJyZW50VGFyZ2V0IE5ldyBjdXJyZW50IHRhcmdldC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0Q3VycmVudFRhcmdldChldmVudCwgY3VycmVudFRhcmdldCkge1xuICAgIHBkKGV2ZW50KS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbn1cblxuLyoqXG4gKiBTZXQgYSBwYXNzaXZlIGxpc3RlbmVyIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbnxudWxsfSBwYXNzaXZlTGlzdGVuZXIgTmV3IHBhc3NpdmUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldFBhc3NpdmVMaXN0ZW5lcihldmVudCwgcGFzc2l2ZUxpc3RlbmVyKSB7XG4gICAgcGQoZXZlbnQpLnBhc3NpdmVMaXN0ZW5lciA9IHBhc3NpdmVMaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBMaXN0ZW5lck5vZGVcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKiBAcHJvcGVydHkgezF8MnwzfSBsaXN0ZW5lclR5cGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGFzc2l2ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBvbmNlXG4gKiBAcHJvcGVydHkge0xpc3RlbmVyTm9kZXxudWxsfSBuZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogQHR5cGUge1dlYWtNYXA8b2JqZWN0LCBNYXA8c3RyaW5nLCBMaXN0ZW5lck5vZGU+Pn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGxpc3RlbmVyc01hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIExpc3RlbmVyIHR5cGVzXG5jb25zdCBDQVBUVVJFID0gMTtcbmNvbnN0IEJVQkJMRSA9IDI7XG5jb25zdCBBVFRSSUJVVEUgPSAzO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3Qgb3Igbm90LlxuICogQHBhcmFtIHthbnl9IHggVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09IFwib2JqZWN0XCIgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG59XG5cbi8qKlxuICogR2V0IGxpc3RlbmVycy5cbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgdG8gZ2V0LlxuICogQHJldHVybnMge01hcDxzdHJpbmcsIExpc3RlbmVyTm9kZT59IFRoZSBsaXN0ZW5lcnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lcnMoZXZlbnRUYXJnZXQpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNNYXAuZ2V0KGV2ZW50VGFyZ2V0KTtcbiAgICBpZiAobGlzdGVuZXJzID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50VGFyZ2V0IG9iamVjdCwgYnV0IGdvdCBhbm90aGVyIHZhbHVlLlwiXG4gICAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RlbmVyc1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgdGhlIGV2ZW50IGF0dHJpYnV0ZSBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBnZXQgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmxpc3RlbmVyVHlwZSA9PT0gQVRUUklCVVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmxpc3RlbmVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHNldChsaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiICYmICFpc09iamVjdChsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcblxuICAgICAgICAgICAgLy8gVHJhdmVyc2UgdG8gdGhlIHRhaWwgd2hpbGUgcmVtb3Zpbmcgb2xkIHZhbHVlLlxuICAgICAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXJUeXBlID09PSBBVFRSSUJVVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIG5ldyB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lclR5cGU6IEFUVFJJQlVURSxcbiAgICAgICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9uY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5ld05vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5ld05vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIERlZmluZSBhbiBldmVudCBhdHRyaWJ1dGUgKGUuZy4gYGV2ZW50VGFyZ2V0Lm9uY2xpY2tgKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFRhcmdldFByb3RvdHlwZSBUaGUgZXZlbnQgdGFyZ2V0IHByb3RvdHlwZSB0byBkZWZpbmUgYW4gZXZlbnQgYXR0cmJpdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGRlZmluZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZWZpbmVFdmVudEF0dHJpYnV0ZShldmVudFRhcmdldFByb3RvdHlwZSwgZXZlbnROYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICBldmVudFRhcmdldFByb3RvdHlwZSxcbiAgICAgICAgYG9uJHtldmVudE5hbWV9YCxcbiAgICAgICAgZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yKGV2ZW50TmFtZSlcbiAgICApO1xufVxuXG4vKipcbiAqIERlZmluZSBhIGN1c3RvbSBFdmVudFRhcmdldCB3aXRoIGV2ZW50IGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBldmVudE5hbWVzIEV2ZW50IG5hbWVzIGZvciBldmVudCBhdHRyaWJ1dGVzLlxuICogQHJldHVybnMge0V2ZW50VGFyZ2V0fSBUaGUgY3VzdG9tIEV2ZW50VGFyZ2V0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQoZXZlbnROYW1lcykge1xuICAgIC8qKiBDdXN0b21FdmVudFRhcmdldCAqL1xuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50VGFyZ2V0KCkge1xuICAgICAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEN1c3RvbUV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogQ3VzdG9tRXZlbnRUYXJnZXQsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBkZWZpbmVFdmVudEF0dHJpYnV0ZShDdXN0b21FdmVudFRhcmdldC5wcm90b3R5cGUsIGV2ZW50TmFtZXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBDdXN0b21FdmVudFRhcmdldFxufVxuXG4vKipcbiAqIEV2ZW50VGFyZ2V0LlxuICpcbiAqIC0gVGhpcyBpcyBjb25zdHJ1Y3RvciBpZiBubyBhcmd1bWVudHMuXG4gKiAtIFRoaXMgaXMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgQ3VzdG9tRXZlbnRUYXJnZXQgY29uc3RydWN0b3IgaWYgdGhlcmUgYXJlIGFyZ3VtZW50cy5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgY2xhc3MgQSBleHRlbmRzIEV2ZW50VGFyZ2V0IHt9XG4gKiAgICAgY2xhc3MgQiBleHRlbmRzIEV2ZW50VGFyZ2V0KFwibWVzc2FnZVwiKSB7fVxuICogICAgIGNsYXNzIEMgZXh0ZW5kcyBFdmVudFRhcmdldChcIm1lc3NhZ2VcIiwgXCJlcnJvclwiKSB7fVxuICogICAgIGNsYXNzIEQgZXh0ZW5kcyBFdmVudFRhcmdldChbXCJtZXNzYWdlXCIsIFwiZXJyb3JcIl0pIHt9XG4gKi9cbmZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIGxpc3RlbmVyc01hcC5zZXQodGhpcywgbmV3IE1hcCgpKTtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQoYXJndW1lbnRzWzBdKVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0eXBlc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQodHlwZXMpXG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIilcbiAgICAvKmVzbGludC1lbmFibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbn1cblxuLy8gU2hvdWxkIGJlIGVudW1lcmFibGUsIGJ1dCBjbGFzcyBtZXRob2RzIGFyZSBub3QgZW51bWVyYWJsZS5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBBZGQgYSBnaXZlbiBsaXN0ZW5lciB0byB0aGlzIGV2ZW50IHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnx7Y2FwdHVyZT86Ym9vbGVhbixwYXNzaXZlPzpib29sZWFuLG9uY2U/OmJvb2xlYW59fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoaXMgbGlzdGVuZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIgJiYgIWlzT2JqZWN0KGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidsaXN0ZW5lcicgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0LlwiKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBjb25zdCBvcHRpb25zSXNPYmogPSBpc09iamVjdChvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IG9wdGlvbnNJc09ialxuICAgICAgICAgICAgPyBCb29sZWFuKG9wdGlvbnMuY2FwdHVyZSlcbiAgICAgICAgICAgIDogQm9vbGVhbihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJUeXBlID0gY2FwdHVyZSA/IENBUFRVUkUgOiBCVUJCTEU7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgICAgIGxpc3RlbmVyVHlwZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IG9wdGlvbnNJc09iaiAmJiBCb29sZWFuKG9wdGlvbnMucGFzc2l2ZSksXG4gICAgICAgICAgICBvbmNlOiBvcHRpb25zSXNPYmogJiYgQm9vbGVhbihvcHRpb25zLm9uY2UpLFxuICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTZXQgaXQgYXMgdGhlIGZpcnN0IG5vZGUgaWYgdGhlIGZpcnN0IG5vZGUgaXMgbnVsbC5cbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBuZXdOb2RlKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhdmVyc2UgdG8gdGhlIHRhaWwgd2hpbGUgY2hlY2tpbmcgZHVwbGljYXRpb24uLlxuICAgICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJlxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXJUeXBlID09PSBsaXN0ZW5lclR5cGVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBpZ25vcmUgZHVwbGljYXRpb24uXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgaXQuXG4gICAgICAgIHByZXYubmV4dCA9IG5ld05vZGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGdpdmVuIGxpc3RlbmVyIGZyb20gdGhpcyBldmVudCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58e2NhcHR1cmU/OmJvb2xlYW4scGFzc2l2ZT86Ym9vbGVhbixvbmNlPzpib29sZWFufX0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGlzIGxpc3RlbmVyLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIGNvbnN0IGNhcHR1cmUgPSBpc09iamVjdChvcHRpb25zKVxuICAgICAgICAgICAgPyBCb29sZWFuKG9wdGlvbnMuY2FwdHVyZSlcbiAgICAgICAgICAgIDogQm9vbGVhbihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJUeXBlID0gY2FwdHVyZSA/IENBUFRVUkUgOiBCVUJCTEU7XG5cbiAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lclR5cGUgPT09IGxpc3RlbmVyVHlwZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBhIGdpdmVuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7RXZlbnR8e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIGV2ZW50IHRvIGRpc3BhdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgZmFsc2VgIGlmIGNhbmNlbGVkLlxuICAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50ID09IG51bGwgfHwgdHlwZW9mIGV2ZW50LnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXZlbnQudHlwZVwiIHNob3VsZCBiZSBhIHN0cmluZy4nKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbGlzdGVuZXJzIGFyZW4ndCByZWdpc3RlcmVkLCB0ZXJtaW5hdGUuXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgY29uc3QgZXZlbnROYW1lID0gZXZlbnQudHlwZTtcbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW5jZSB3ZSBjYW5ub3QgcmV3cml0ZSBzZXZlcmFsIHByb3BlcnRpZXMsIHNvIHdyYXAgb2JqZWN0LlxuICAgICAgICBjb25zdCB3cmFwcGVkRXZlbnQgPSB3cmFwRXZlbnQodGhpcywgZXZlbnQpO1xuXG4gICAgICAgIC8vIFRoaXMgZG9lc24ndCBwcm9jZXNzIGNhcHR1cmluZyBwaGFzZSBhbmQgYnViYmxpbmcgcGhhc2UuXG4gICAgICAgIC8vIFRoaXMgaXNuJ3QgcGFydGljaXBhdGluZyBpbiBhIHRyZWUuXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgbGlzdGVuZXIgaWYgaXQncyBvbmNlXG4gICAgICAgICAgICBpZiAobm9kZS5vbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxsIHRoaXMgbGlzdGVuZXJcbiAgICAgICAgICAgIHNldFBhc3NpdmVMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICB3cmFwcGVkRXZlbnQsXG4gICAgICAgICAgICAgICAgbm9kZS5wYXNzaXZlID8gbm9kZS5saXN0ZW5lciA6IG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUubGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIuY2FsbCh0aGlzLCB3cmFwcGVkRXZlbnQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lclR5cGUgIT09IEFUVFJJQlVURSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBub2RlLmxpc3RlbmVyLmhhbmRsZUV2ZW50ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIuaGFuZGxlRXZlbnQod3JhcHBlZEV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQnJlYWsgaWYgYGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbmAgd2FzIGNhbGxlZC5cbiAgICAgICAgICAgIGlmIChpc1N0b3BwZWQod3JhcHBlZEV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0UGFzc2l2ZUxpc3RlbmVyKHdyYXBwZWRFdmVudCwgbnVsbCk7XG4gICAgICAgIHNldEV2ZW50UGhhc2Uod3JhcHBlZEV2ZW50LCAwKTtcbiAgICAgICAgc2V0Q3VycmVudFRhcmdldCh3cmFwcGVkRXZlbnQsIG51bGwpO1xuXG4gICAgICAgIHJldHVybiAhd3JhcHBlZEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWRcbiAgICB9LFxufTtcblxuLy8gYGNvbnN0cnVjdG9yYCBpcyBub3QgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFRhcmdldC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwge1xuICAgIHZhbHVlOiBFdmVudFRhcmdldCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG59KTtcblxuLy8gRW5zdXJlIGBldmVudFRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5FdmVudFRhcmdldGAgaXMgYHRydWVgLlxuaWYgKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2Ygd2luZG93LkV2ZW50VGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiXG4pIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlKTtcbn1cblxuZXhwb3J0cy5kZWZpbmVFdmVudEF0dHJpYnV0ZSA9IGRlZmluZUV2ZW50QXR0cmlidXRlO1xuZXhwb3J0cy5FdmVudFRhcmdldCA9IEV2ZW50VGFyZ2V0O1xuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRUYXJnZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXRcbm1vZHVsZS5leHBvcnRzLkV2ZW50VGFyZ2V0ID0gbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRXZlbnRUYXJnZXRcbm1vZHVsZS5leHBvcnRzLmRlZmluZUV2ZW50QXR0cmlidXRlID0gZGVmaW5lRXZlbnRBdHRyaWJ1dGVcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50LXRhcmdldC1zaGltLmpzLm1hcFxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicHJpdmF0ZURhdGEiLCJXZWFrTWFwIiwid3JhcHBlcnMiLCJwZCIsImV2ZW50IiwicmV0diIsImdldCIsImNvbnNvbGUiLCJhc3NlcnQiLCJzZXRDYW5jZWxGbGFnIiwiZGF0YSIsInBhc3NpdmVMaXN0ZW5lciIsImVycm9yIiwiY2FuY2VsYWJsZSIsImNhbmNlbGVkIiwicHJldmVudERlZmF1bHQiLCJFdmVudCIsImV2ZW50VGFyZ2V0Iiwic2V0IiwiZXZlbnRQaGFzZSIsImN1cnJlbnRUYXJnZXQiLCJzdG9wcGVkIiwiaW1tZWRpYXRlU3RvcHBlZCIsInRpbWVTdGFtcCIsIkRhdGUiLCJub3ciLCJlbnVtZXJhYmxlIiwia2V5cyIsImkiLCJsZW5ndGgiLCJrZXkiLCJkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3IiLCJwcm90b3R5cGUiLCJ0eXBlIiwidGFyZ2V0IiwiY29tcG9zZWRQYXRoIiwiTk9ORSIsIkNBUFRVUklOR19QSEFTRSIsIkFUX1RBUkdFVCIsIkJVQkJMSU5HX1BIQVNFIiwic3RvcFByb3BhZ2F0aW9uIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiYnViYmxlcyIsIkJvb2xlYW4iLCJkZWZhdWx0UHJldmVudGVkIiwiY29tcG9zZWQiLCJzcmNFbGVtZW50IiwiY2FuY2VsQnViYmxlIiwicmV0dXJuVmFsdWUiLCJpbml0RXZlbnQiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIndpbmRvdyIsInNldFByb3RvdHlwZU9mIiwiZGVmaW5lQ2FsbERlc2NyaXB0b3IiLCJhcHBseSIsImFyZ3VtZW50cyIsImRlZmluZVdyYXBwZXIiLCJCYXNlRXZlbnQiLCJwcm90byIsIkN1c3RvbUV2ZW50IiwiY2FsbCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiZGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzRnVuYyIsImdldFdyYXBwZXIiLCJ3cmFwcGVyIiwiZ2V0UHJvdG90eXBlT2YiLCJ3cmFwRXZlbnQiLCJXcmFwcGVyIiwiaXNTdG9wcGVkIiwic2V0RXZlbnRQaGFzZSIsInNldEN1cnJlbnRUYXJnZXQiLCJzZXRQYXNzaXZlTGlzdGVuZXIiLCJsaXN0ZW5lcnNNYXAiLCJDQVBUVVJFIiwiQlVCQkxFIiwiQVRUUklCVVRFIiwiaXNPYmplY3QiLCJ4IiwiZ2V0TGlzdGVuZXJzIiwibGlzdGVuZXJzIiwiVHlwZUVycm9yIiwiZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yIiwiZXZlbnROYW1lIiwibm9kZSIsImxpc3RlbmVyVHlwZSIsImxpc3RlbmVyIiwibmV4dCIsInByZXYiLCJkZWxldGUiLCJuZXdOb2RlIiwicGFzc2l2ZSIsIm9uY2UiLCJkZWZpbmVFdmVudEF0dHJpYnV0ZSIsImV2ZW50VGFyZ2V0UHJvdG90eXBlIiwiZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQiLCJldmVudE5hbWVzIiwiQ3VzdG9tRXZlbnRUYXJnZXQiLCJFdmVudFRhcmdldCIsIk1hcCIsIkFycmF5IiwiaXNBcnJheSIsInR5cGVzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9wdGlvbnMiLCJvcHRpb25zSXNPYmoiLCJjYXB0dXJlIiwidW5kZWZpbmVkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRpc3BhdGNoRXZlbnQiLCJ3cmFwcGVkRXZlbnQiLCJlcnIiLCJoYW5kbGVFdmVudCIsImRlZmF1bHQiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/event-target-shim/dist/event-target-shim.js\n");

/***/ })

};
;